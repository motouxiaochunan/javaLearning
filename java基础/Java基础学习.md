# Java基础学习

## 编程基础

### 函数调用的基本原理

程序从main函数开始顺序执行，函数调用可以看作一个无条件跳转，跳转到对应函数的指令处开始执行，碰到return语句或者函数结尾时，再执行一次无条件跳转，跳转回调用方，执行调用函数后的下一次指令。

但这里面有几个问题：

1. **参数如何传递？**

2. **函数如何知道返回到什么地方？**

3. **函数结果如何传给调用方？**

计算机系统主要使用栈来存放函数调用过程中需要的数据，包括参数、返回地址以及函数内定义的局部变量。

具体来说，当main函数调用其他函数时，会将**函数的参数**、**main函数下一条指令的地址**、**局部变量值**依次压入栈。

### 基本数据类型

#### 小数计算为什么会出错

因为计算机是用一种二进制的格式存储小数的，这个二进制格式不能精确表示0.1，因为二进制数表示为1/2的n次方。

另一种方法是使用十进制的数据类型，在Java中是BigDecimal，运算更准确但效率比较低。

### 字符的编码乱码

#### 非Unicode编码

非**Unicode**编码，英文用一个字节来表示字符，中文用两个字节来表示一个汉字。

#### Unicode编码

每个国家对自己常用的字符进行编码，在编码的时候忽略了其他国家的字符和编码，因此出现了太多互不兼容的编码。

**Unicode**给世界上所有字符都分配了一个唯一的数字编号，这个编号范围从0x000000~0x10FFFF，包括110多万。大部分常用字符在0x0000~0xFFFF之间，即65536个数字之间。大部分中文编号范围在4E00~9FFF。

**那么编号怎么对应到二进制表示呢？**

+ UTF-32，字符编号的整数二进制形式，4个字节。

+ UTF-16，对于U+0000~U+FFFF的字符，直接用两个字节表示。
  
  对于U+10000~U+10FFFF的字符，用4个字节表示。

+ UTF-8
  
  使用变长字节表示，每个字符使用的字节个数和Unicode编号大小有关，编号小的使用字节少，编号大的使用字节多。

#### 编码转换

根据编码方式的不同，每一个字符可能有多种不兼容的编码方式。

不同格式之间可以借助Unicode编号进行编码转换。每种编码都有一个映射表，存储特有的字符编码和Unicode编号之间的对应关系。

一个字符从A编码转到B编码，可以先找到字符的A编码格式，通过A的映射表找到其Unicode编号，然后通过Unicode编号再查B的映射表，找到字符的B编码格式。

**乱码的原因**

+ **解析错误**。使用了错误的编码格式进行解析。

+ **解析和编码转换错误**。实际编码格式与系统以为的编码格式不一致。

**java恢复乱码**

String中有两个重要的方法：

1. `public byte[]getBytes(String charsetName)`
   
   这个方法可以获取一个字符串的给定编码格式的二进制形式。

2. `public String(byte bytes[],String charsetName)`，这个构造方法以给定的二进制数组bytes按照编码格式charsetName解读为一个字符串。

#### char的真正含义

Java内部进行字符处理时，采用的都是Unicode，具体编码格式是UTF-16BE。

**char本质上是一个固定占用两个字节的无符号正整数，这个正整数对应于Unicode编号，用于表示那个编号对应的字符。**

### 类路径是什么

java编译和运行时，都需要以参数指定一个classpath，即类路径。

在**Java源代码编译**时，Java编译器会确定引用的每个类的全限定名，确定的方式是根据import语句和classpath。如果导入的是全限定类名，则可以直接比较并确定，如果是模糊导入则根据classpath找对应父包，再在父包下寻找是否有对应类。

在**Java运行**时，根据类的全限定名寻找并加载类，寻找的方式就是在类路径中寻找，如果是class文件根目录，则直接查看是否有对应的子目录和文件，如果是jar文件，则首先在内存中解压文件，然后查看是否有对应类。

## 类的继承

### 动态绑定

在父类构造方法中调用被子类重写的方法，调用的是被子类重写的方法而不是父类的方法。

### 继承访问权限protected

protected表示不能被外部任意访问，但可被子类访问。另外，protected还表示可以被同一个包中其他类访问。

### 为什么说继承是把双刃剑

**继承破坏封装**

**继承可能破坏封装是因为子类和父类之间可能存在着实现细节的依赖**。子类在继承父类时，往往不得不关注类的实现细节，而父类在修改其内部实现时，如果不考虑子类，往往也会影响到子类。

## 类的扩展

### 使用接口替代继承

使用组合替代继承，可以复用代码但不能统一处理。

使用接口替代继承，可以实现统一处理不同类型的对象，但接口没有代码实现，无法复用代码。

将组合和接口结合起来替代继承，就既可以统一处理，又可以复用代码了。

### 抽象类

**抽象类和接口是配合而非替代关系，它们经常一起使用，接口声明能力，抽象类提供默认实现，实现全部或部分方法，一个接口经常有一个对应的抽象类**。比如，在Java类库中有：

+ Collection接口和对应的AbstractCollection抽象类。

+ List接口和对应的AbstractList抽象类。

+ Map接口和对应的AbstractMap抽象类。

对于需要实现接口的具体类而言，有两个选择：一个是实现接口，自己实现全部方法；另一个则是继承抽象类，根据需要重写方法。

继承的好处是复用代码，只重写需要的部分即可。

### 内部类

内部类与包含它的外部类有比较密切的关系，而与其他类关系不大，定义在类内部可以实现对外部完全隐藏，有更好的封装性，代码实现上也往往更加简洁。

不过内部类只是Java编译器的概念，对于Java虚拟机而言，每个内部类最后都会被编译为一个独立的类。

### 枚举的本质

枚举的好处：

+ **更安全**。一个枚举类型的变量，值要么为null，要么为枚举值之一，不可能为其他值。

+ **枚举类型自带很多遍历方法**。如values、valueOf、toString等，易于使用。

**枚举的实现**

枚举类型实际上会被Java编译器转换为一个对应的类，这个类继承了Java API中的java.lang.Enum类。Enum类中有name和ordinal两个实例变量，在构造方法中需要传递。

## 异常

**Error**表示系统错误或资源耗尽，由系统自己使用，应用程序不应抛出和处理，比如**虚拟机错误(VirtualMacheError)**、**内存溢出错误(OutOfMemoryError)**、**栈溢出错误(StackOverflowError)**。

**Exception**表示应用程序错误，包括**IOException**、**RuntimeException**、**SQLException**。

**RuntimeException**比较特殊，它的实际含义是未受检异常，相对而言Exception的其他子类是受检异常。

对于受检异常，Java会强制要求程序员进行处理，否则有编译错误，而对于未受检异常没有这个要求。

### RuntimeException的子类

+ NullPointerException 空指针异常。

+ IllegalStateException 非法状态。

+ ClassCastException 非法强制类型转换。

+ IllegalArgumentException 参数错误。

大部分类在继承Throwable类后只是定义了几个构造方法，这些构造方法也只是调用了父类的构造方法，没有额外的操作。

定义这么多不同的类主要是为了名字不同。异常类本身的名字就代表了异常的关键信息。

### 如何使用异常

**异常处理的目标**

异常大概可以分为三种来源：用户、程序员、第三方。

用户指用户输入有问题，程序员指程序员编程错误，第三方泛指I/O错误、网络、数据库、第三方服务等。

## 常用基础类

### Arrays中的排序

Java7以后，对于基本类型的数组，Java采用的算法是双枢轴快速排序。在此之前，Java采取的算法是普通的快速排序。

对于对象类型，Java采用的是TimSort。TimSort实际上是对归并排序的一系列优化。

**为什么基本类型和对象类型的算法不一样？**

排序算法有一个稳定性的概念，如果排序前后相对顺序不变，那算法就是稳定的，否则就是不稳定的。

快速排序更快，但不稳定，归并排序是稳定的。对于基本类型，值相同就是完全相同，所以稳定不稳定没关系。

## 泛型

### 泛型的好处

+ 更好的安全性

+ 更好的可读性

### 通配符

\<T extends E>和\<? extends E>的区别

+ **通配符形式都可以用类型参数的形式来替代**。

+ **通配符形式可以减少类型参数**。形式上更加简单，可读性也更好。

+ 如果类型参数间有依赖，或返回值依赖类型参数，或需要写操作，只能用类型参数。

+ **通配符和类型参数往往配合使用**。
