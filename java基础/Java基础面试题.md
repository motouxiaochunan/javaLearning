# Java基础面试题

## java基础

### java和C++的区别

1. Java的类是单继承的，C++支持多重继承。

2. C++提供指针来访问内存，Java不提供。

3. C++需要管理对象的创建和销毁，Java有垃圾回收机制自动释放无用内存。

### 静态变量的作用，哪里会用

静态变量只会被分配一次内存，被类的所有对象共享。

一般用于修饰常量或工具类的方法。

### 静态方法为什么不能调用非静态成员

静态方法是属于类的，在类加载时就会分配内存，此时调用类中还不存在的非静态成员属于非法操作。

### 重载和重写有什么区别

**重载**指的是同样一个方法能够根据输入数据不同作出不同的处理。

**重写**是当子类继承父类的相同方法，输入数据一样但要作出与父类

## 面向对象基础

### ==和equals的区别

### 面向对象三大特征

1. **封装**。
   
   **封装**是指把一个对象的状态信息隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。

2. **继承**。
   
   **继承**以已存在类的定义作为基础建立新的类。可以提高代码的重用、可维护性，节省大量创建新类的时间。

3. **多态**。
   
   一个对象具有多种状态，具体表现为父类引用指向子类的实例。

### 接口和抽象类有什么共同点和区别

**共同点**：

1. 接口和抽象类都不能实例化。

2. 接口和抽象类都可以包含抽象方法。

**区别**：

1. 接口主要表示行为，抽象类用于代码复用强调从属关系。

2. 一个类只能继承一个抽象类但可以实现多个接口。

3. 接口中的成员变量只能是public static final类型，抽象类中可以有任何修饰符。

### 深拷贝和浅拷贝的区别

**浅拷贝**：如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，拷贝对象和原对象共用一个地址。

**深拷贝**：深拷贝会完全复制整个对象，包括这个对象的内部对象。

## 异常

### Exception和Error有什么区别

Error属于程序无法处理的错误，比如OutOfMemoryError、NoClassDefFoundError等。

### RunTimeException和IO Exception有什么区别

由程序错误导致的异常属于**RuntimeException**，包括：

+ 错误的类型转换。

+ 数组访问越界。

+ 访问null指针。

**IOException**包括：

+ 在文件尾部后面读取数据。

+ 打开一个不存在的文件。

+ 根据给定字符串查找Class对象，而这个类不存在。

## 反射

### 反射的应用场景

Spring框架中的AOP模块大量使用了动态代理，而动态代理的实现依赖反射。

Java中的注解实现也用到了反射。

比如Spring中可以用@Component注解声明一个类为SpringBean，省去了在xml文件中配置的过程。

### 什么是注解

注解用于修饰类、方法或变量，提供某些信息供程序在编译或者运行时使用。

### 注解怎样被解析

## 序列化和反序列化

### 什么是序列化

当需要持久化Java对象如将Java对象保存在文件中或在网络中传输对象时，需要用到**序列**化将对象写出到输出流中，并在之后将其读回。

## JavaIO

Java API中，可以从中读入一个字节序列的对象称作**输入流**，而可以向其中写入一个字节序列的对象称作**输出流**。

### 在哪里用过IO

**System.in**：InputStream一个子类的预定义对象，从控制台读入信息。

**System.out**：从控制台输出信息。

**FileInputStream、FileOutputStream**：从文件中读入、输出信息。

### I/O流为什么分为字节流和字符流

在许多情况下，我们希望操作的是文本，即字符序列，因此需要考虑字符如何编码成字节。

### BIO、NIO和AIO的区别

**同步阻塞BIO**

在BIO中，应用程序发起read调用后，会一直阻塞到内核把数据拷贝到用户空间。

**同步非阻塞NIO**

在NIO中，应用程序会一直发起read调用，直到从内核空间拷贝数据到用户空间，NIO通过轮询操作避免了一直阻塞，但一直调用轮询数据是十分消耗CPU资源的。

**异步模型AIO**

异步IO基于事件和回调机制实现，在read调用之后直接返回，当后台处理完成，操作系统会通知相应的线程进行后续操作。

## 集合

### ArrayList和数组的区别

+ `ArrayList`可以动态扩容或缩容，数组不能改变长度。

+ `ArrayList`只能存储对象，数组可以存储基本类型数据和对象。

+ `ArrayList`创建时不需要指定大小，数组必须指定。

### HashMap和Hashtable的区别

+ `HashMap`是非线程安全的，`Hashtable`内部的方法基本都经过`synchronized`修饰因此是线程安全的。

+ `HashMap`可以存储null的key和value，`Hashtable`不可以。

+ JDK1.8以后`HashMap`在数组长度>=64且链表长度大于阈值时会将链表转化为红黑树，`Hashtable`没有这样的机制。

+ `HashMap`对`hashcode`值进行混合扰动以减少冲突，而`Hashtable`直接使用`hashcode`值。

### HashMap底层实现

**JDK1.8之前**

JDK1.8之前`HashMap`底层是数组和链表结合在一起使用。`HashMap`通过key的`hashcode`经过扰动函数处理得到哈希值，通过`(n-1)&hash`判断当前元素存放的位置。如果当前位置存在元素，就判断该元素与要存入的元素hash值以及key是否相同，如果相同就覆盖，不同就通过拉链法解决冲突。

**JDK1.8之后**

JDK1.8之后在解决哈希冲突有了较大变化，当数组长度大于等于64且当链表长度大于阈值时，链表转化为红黑树以减少搜索时间。

### 红黑树是什么数据结构

### HashMap的长度为什么是2的幂次方

取余(%)操作中如果除数是2的幂次方则等价于与其除数减一的与(&)操作。

1. **位运算效率更高**。位运算&比取余运算%更高效。当长度为2的幂次方时，`hash%length`等价于`hash&(length-1)`。

2. 在扩容之后，在旧数组hash值比较均匀的情况下，**新数组也会被分配得比较均匀**。

3. 扩容机制变得简单高效，要么位置不变，要么移动到新位置。

### ConcurrentHashMap和Hashtable的区别

+ 在JDK1.7，`ConcurrentHashMap`对整个数组进行分段，每一把锁只锁容器中一部分数据，多线程访问容器里不同数据段的数据不存在锁竞争，提高了并发访问率。

+ 在JDK1.8，`ConcurrentHashMap`摒弃了`Segment`概念，直接用`Node`数组+链表+红黑树的数据结构来实现，使用`synchronized`和CAS来进行并发控制。看起来像优化过且线程安全的HashMap。

+ `Hashtable`用`synchronized`修饰方法，比`ConcurrentHashMap`并发粒度更粗，且没有使用CAS进行并发操作，因此效率更低。

### ConcurrentHashMap的底层实现

**JDK1.8之前**

首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他数据访问。

**JDK1.8之后**

取消了`Segment`分段锁，采用`Node+CAS+synchronized`保证并发安全，数据结构与`HashMap`1.8的结构类似。

`synchronized`锁粒度更细，只锁定当前链表或红黑树的首节点，只要hash不冲突就不会产生并发。
