# Java基础面试题

## java基础

### java和C++的区别

1. Java的类是单继承的，C++支持多重继承。

2. C++提供指针来访问内存，Java不提供。

3. C++需要管理对象的创建和销毁，Java有垃圾回收机制自动释放无用内存。

### 静态变量的作用，哪里会用

静态变量只会被分配一次内存，被类的所有对象共享。

一般用于修饰常量或工具类的方法。

### 静态方法为什么不能调用非静态成员

静态方法是属于类的，在类加载时就会分配内存，此时调用类中还不存在的非静态成员属于非法操作。

### 重载和重写有什么区别

**重载**指的是同样一个方法能够根据输入数据不同作出不同的处理。

**重写**是当子类继承父类的相同方法，输入数据一样但要作出与父

## 面向对象基础

### ==和equals的区别

### 面向对象三大特征

1. **封装**。
   
   **封装**是指把一个对象的状态信息隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。

2. **继承**。
   
   **继承**以已存在类的定义作为基础建立新的类。可以提高代码的重用、可维护性，节省大量创建新类的时间。

3. **多态**。
   
   一个对象具有多种状态，具体表现为父类引用指向子类的实例。

### 接口和抽象类有什么共同点和区别

**共同点**：

1. 接口和抽象类都不能实例化。

2. 接口和抽象类都可以包含抽象方法。

**区别**：

1. 接口主要表示行为，抽象类用于代码复用强调从属关系。

2. 一个类只能继承一个抽象类但可以实现多个接口。

3. 接口中的成员变量只能是public static final类型，抽象类中可以有任何修饰符。

### 深拷贝和浅拷贝的区别

**浅拷贝**：如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，拷贝对象和原对象共用一个地址。

**深拷贝**：深拷贝会完全复制整个对象，包括这个对象的内部对象。

### String s1=new String("abc")这句话创建了几个字符串对象？

创建了1或2个字符串对象。

1. 如果字符串常量池不存在"abc"：创建2个字符串对象，一个在字符串常量池中。一个在堆中，由`new String()`创建，并使用常量池中的"abc"初始化。

2. 如果字符串常量池中已经存在"abc"，会创建1个字符串对象。该对象在堆中，由`new String()`创建。

### String的变量和常量做"+"运算时发生了什么？

对于编译期间可以确定值的常量字符串，jvm会在编译期间就将其存入字符串常量值。

常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中。

对于`String str3="str"+"ing"`，编译器会优化成`String str3="string"`。

**但引用的值在程序编译期间是无法确定的，编译器无法进行优化。**

对象引用和"+"的拼接，实际上是通过`StringBuilder`调用`append()`方法实现的，拼接完成后调用`toString()`得到一个`String`对象。

## 异常

### Exception和Error有什么区别

Error属于程序无法处理的错误，比如`OutOfMemoryError`、`NoClassDefFoundError`等。

### RunTimeException和IO Exception有什么区别

由程序错误导致的异常属于**RuntimeException**，包括：

+ 错误的类型转换。

+ 数组访问越界。

+ 访问null指针。

**IOException**包括：

+ 在文件尾部后面读取数据。

+ 打开一个不存在的文件。

+ 根据给定字符串查找Class对象，而这个类不存在。

### 捕获Error的情况？

**Error**的出现代表的是一些严重的非正常错误，这些Error的出现代表的是程序已经不用进行处理了，比如OutOfMemoryError，如果出现这个错误的话，程序已经无法运行下去，捕获也没有意义了。

## 反射

### 反射的应用场景

**反射**赋予了在运行时分析类以及执行类中方法的能力，通过反射可以获取类的所有属性和方法，并调用这些属性和方法。

Spring框架中的AOP模块大量使用了动态代理，而动态代理的实现依赖反射。

Java中的注解实现也用到了反射，可以基于反射分析类，获取到类/属性/方法/方法的参数上的注解，获取到注解之后可以做进一步的处理。

比如Spring中可以用@Component注解声明一个类为SpringBean，省去了在xml文件中配置的过程。

### 什么是注解

注解本质是一个继承了`Annotation`的特殊接口。

### 注解怎样被解析

+ **编译期直接扫描**：编译器在编译Java代码时扫描对应的注解并处理。

+ **运行期通过反射处理**：在运行期间通过反射来进行处理。

## 泛型

### 泛型是什么？有什么用？

使用泛型参数，可以增强代码的可读性以及稳定性。

编译器可以对泛型参数进行检测，通过泛型参数可以指定传入的对象类型，比如`ArrayList<Person> persons= new ArrayList<Person>()`这行代码就指明了该`ArrayList`对象只能传入`Person`对象，如果传入其他对象就会报错。

## 序列化和反序列化

### 什么是序列化

当需要持久化Java对象如将Java对象保存在文件中或在网络中传输对象时，需要用到**序列**化将对象写出到输出流中，并在之后将其读回。

## JavaIO

Java API中，可以从中读入一个字节序列的对象称作**输入流**，而可以向其中写入一个字节序列的对象称作**输出流**。

### 在哪里用过IO

**System.in**：InputStream一个子类的预定义对象，从控制台读入信息。

**System.out**：从控制台输出信息。

**FileInputStream、FileOutputStream**：从文件中读入、输出信息。

### I/O流为什么分为字节流和字符流

在许多情况下，我们希望操作的是文本，即字符序列，因此需要考虑字符如何编码成字节。

### BIO、NIO和AIO的区别

**同步阻塞BIO**

在BIO中，应用程序发起read调用后，会一直阻塞到内核把数据拷贝到用户空间。

**同步非阻塞NIO**

在NIO中，应用程序会一直发起read调用，直到从内核空间拷贝数据到用户空间，NIO通过轮询操作避免了一直阻塞，但一直调用轮询数据是十分消耗CPU资源的。

**异步模型AIO**

异步IO基于事件和回调机制实现，在read调用之后直接返回，当后台处理完成，操作系统会通知相应的线程进行后续操作。

## 集合

### ArrayList和数组的区别

+ `ArrayList`可以动态扩容或缩容，数组不能改变长度。

+ `ArrayList`只能存储对象，数组可以存储基本类型数据和对象。

+ `ArrayList`创建时不需要指定大小，数组必须指定。

## PriorityQueue

+ `PriorityQueue`利用二叉堆的数据结构实现，底层使用可变长的数组存储。

+ `PriorityQueue`不支持存储null和non-comparable对象。

+ `PriorityQueue`默认是小顶堆，但可以接收`Comparator`来自定义元素优先级先后。

### BlockingQueue

线程池中用到的就是BlockingQueue，管理线程把事件放入队列，线程池中的线程将事件取出队列。

### HashMap和Hashtable的区别

+ `HashMap`是非线程安全的，`Hashtable`内部的方法基本都经过`synchronized`修饰因此是线程安全的。

+ `HashMap`可以存储null的key和value，`Hashtable`不可以。

+ JDK1.8以后`HashMap`在数组长度>=64且链表长度大于阈值时会将链表转化为红黑树，`Hashtable`没有这样的机制。

+ `HashMap`对`hashcode`值进行混合扰动以减少冲突，而`Hashtable`直接使用`hashcode`值。

### HashMap和TreeMap的区别

`TreeMap`额外实现了`NavigableMap`和`SortedMap`接口。

`NavigableMap`让`TreeMap`有了对集合内元素搜索的能力。

`SortedMap`让`TreeMap`有了对集合中元素根据键排序的能力。

### HashMap底层实现

**JDK1.8之前**

JDK1.8之前`HashMap`底层是数组和链表结合在一起使用。`HashMap`通过key的`hashcode`经过扰动函数处理得到哈希值，通过`(n-1)&hash`判断当前元素存放的位置。如果当前位置存在元素，就判断该元素与要存入的元素hash值以及key是否相同，如果相同就覆盖，不同就通过拉链法解决冲突。

**JDK1.8之后**

JDK1.8之后在解决哈希冲突有了较大变化，当数组长度大于等于64且当链表长度大于阈值时，链表转化为红黑树以减少搜索时间。

### 红黑树是什么数据结构

### HashMap的长度为什么是2的幂次方

取余(%)操作中如果除数是2的幂次方则等价于与其除数减一的与(&)操作。

1. **位运算效率更高**。位运算&比取余运算%更高效。当长度为2的幂次方时，`hash%length`等价于`hash&(length-1)`。

2. 在扩容之后，在旧数组hash值比较均匀的情况下，**新数组也会被分配得比较均匀**。

3. 扩容机制变得简单高效，要么位置不变，要么移动到新位置。

### ConcurrentHashMap和Hashtable的区别

+ 在JDK1.7，`ConcurrentHashMap`对整个数组进行分段，每一把锁只锁容器中一部分数据，多线程访问容器里不同数据段的数据不存在锁竞争，提高了并发访问率。

+ 在JDK1.8，`ConcurrentHashMap`摒弃了`Segment`概念，直接用`Node`数组+链表+红黑树的数据结构来实现，使用`synchronized`和CAS来进行并发控制。看起来像优化过且线程安全的HashMap。

+ `Hashtable`用`synchronized`修饰方法，比`ConcurrentHashMap`并发粒度更粗，且没有使用CAS进行并发操作，因此效率更低。

### ConcurrentHashMap的底层实现

**JDK1.8之前**

首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他数据访问。

**JDK1.8之后**

取消了`Segment`分段锁，采用`Node+CAS+synchronized`保证并发安全，数据结构与`HashMap`1.8的结构类似。

`synchronized`锁粒度更细，只锁定当前链表或红黑树的首节点，只要hash不冲突就不会产生并发。
