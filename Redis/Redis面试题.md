# Redis面试题

## Redis为什么快？

+ Redis基于内存，内存的访问速度比磁盘快。

+ Redis基于单线程事件循环和IO多路复用，设计开发了一套高效的事件处理模型。

+ Redis内置了优化过后的数据类型/结构实现，性能非常高。

## Redis和Memcached的区别和共同点？

**共同点**：

1. 都是基于内存的数据库。

2. 都有过期策略。

**不同点**：

1. Redis支持更丰富的数据类型，除k/v类型外还提供list、set、zset、hash等数据结构的存储。

2. **数据持久化**。Redis支持数据持久化，而Memcached把数据全部存在内存中。

3. **集群模式支持**。Memcached没有原生的集群模式，而Redis是原生支持集群模式的。

4. **线程模型**。Memcached是多线程，非阻塞IO服用的网络模型；Redis是单线程的多路IO复用模型。

5. **特性支持**。Redis支持发布订阅模型、Lua脚本、事务等功能，而Memcached不支持。

6. **过期数据删除**。Memcached过期数据的删除策略只用了惰性删除，而Redis同时支持惰性删除与定期删除。

## Redis缓存读写策略

**读的过程统一为**：

1. 从cache中读取数据，读取到就返回。

2. cache中读取不到，从db中读取数据返回。

3. 把数据放到cache中。

**写的策略分为三种**：

+ **旁路缓存模式**。 
  
  1. 先更新db。
  
  2. 然后直接删除cache。
  
  不能先删除cache然后更新db，因为在更新db的过程中数据不一致。

+ **读写穿透**。
  
  读写穿透中将cache视为主要数据存储。
  
  1. 先查cache，cache中不存在则直接更新db。
  
  2. cache中存在，则先更新cache，然后cache服务自己更新db。

+ **异步缓存写入**。
  
  异步缓存写入与读写穿透类似，但是在第二步中只更新缓存，不直接更新db，而是改为异步批量的方式来更新db。

## 如何基于Redis实现延时任务？

## Redis持久化机制

### RDB（Redis Database BackupFile） 持久化

Redis可以通过创建快照来获得内存数据在**某个时间点**上的副本。

快照持久化是Redis默认采用的持久化方式。

在`redis.conf`配置文件中默认有以下配置：

+ `save 900 1`，在900s之后，如果有1个key发生变化，redis会自动触发`bgsave`创建快照。

+ `save 300 10`，在300s之后，如果至少有10个key发生变化，redis会自动触发`bgsave`创建快照。

+ `save 60 10000`，在60s之后，如果至少有1W个key发生变化，Redis会自动触发`bgsave`创建快照。

### AOF（Append-only file） 持久化

与快照持久化相比，**AOF持久化**的实时性更好。

开启**AOF持久化**后每执行一条会更改Redis中数据的命令，Redis就会将该命令写入到AOF缓冲区中，然后再写入到AOF文件中（系统内核缓冲区），最后根据持久化方式的配置来决定何时将系统内核缓存区的数据同步到硬盘中。

**AOF持久化方式有哪些？**

1. `appendfsync always`：主线程调用`write`执行写操作后，后台线程立即调用`fsync`刷盘。

2. `appendfsync everysec`：主线程调用`write`执行写操作后立即返回，由后台线程每秒钟调用`fsync`函数。

3. `appendfsync no`：主线程执行写操作后立即返回，让操作系统决定何时进行同步，Linux下一般为30s一次。

为了兼顾数据和写入性能，可以考虑`appendfsync everysec`，让Redis每秒同步一次AOF文件，Redis性能受到影响较小。这样即使出现系统崩溃，用户最多只会丢失1s内产生的数据。

## Redis线程模型

## 缓存读写策略

## Redis数据类型

+ 5种基础数据类型：String、List、Set、Hash、Zset。

**应用场景**

+ List：最新文章、最新动态。

+ Hash：用户信息、商品信息等对象。

+ Set：存放的数据不能重复的场景，文章点赞人员等。

+ Sorted Set：需要获取元素根据某个权重进行排序的场景，如各种排行榜等。

+ 3种特殊数据类型：HyperLogLog、Bitmap、Geospatial。

## Redis内存管理

## Redis事务

## Redis性能优化

## Redis生产问题

## Redis集群

### 什么是sentinel？有什么用？

哨岗、哨兵是Redis高可用性的解决方案：由一个或多个**Sentinel**实例组成的**Sentinel**系统可以监视多个主服务器以及主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将从服务器升级为新的主服务器。

### Sentinal如何检测节点是否下线？主观下线和客观下线的区别？

+ **主观下线**。在默认情况下，**Sentinel**会以每秒一次的频率向所有与它创建了命令连接的实例(包括主服务器、从服务器)发送PING命令，并通过实例返回的PING命令回复来判断实例是否在线。
  
  如果一个实例在down-after-milliseconds毫秒内，连续向**Sentinel**返回无效回复，那么**Sentinel**会修改这个实例对应的实例结构，来表示这个实例已经进入主观下线状态。

+ **客观下线**。当Sentinel将一个主服务器判断为主观下线后，为了确认这个主服务器是否真的下线了，它会向同样监视这一主服务器的Sentinel进行询问，看它们是否也认为主服务器已经进入了下线状态。当Sentinel从其他Sentinel那里接收到足够数量的已下线判断后，Sentinel就会将服务器判定为客观下线。

### Sentinal如何实现故障转移？

在选举产生出领头Sentinel之后，领头Sentinel将对已下线的主服务器执行故障转移操作，该操作包含以下三个步骤：

1. 在已下线主服务器的所有从服务器里，挑选出一个从服务器转换为主服务器。

2. 让已下线主服务器属下的所有从服务器改为复制新的主服务器。

3. 将已下线主服务器设置为新的主服务器的从服务器。

**新的主服务器怎样挑选出来**

1. 删除列表中所有处于下线或者断线状态的从服务器。

2. 删除列表中最近5s内没有回复过领头Sentinel的INFO命令的从服务器。

3. 删除所有与已下线主服务器连接断开超过**主观下线时间*10**的从服务器，则可以保证列表中剩余的从服务器都没有过早地与主服务器断开连接。

4. 根据从服务器的优先级，对列表中剩余的从服务器进行排序。

### 为什么建议部署多个sentinal节点？

**防止误判**，多个Sentinel节点共同完成对节点故障的判断，可以有效防止因单个节点故障导致的误判。例如，某个Sentinel节点可能因为网络问题而无法连接到主节点上。

### Sentinal如何选择出新的master？

当一个主服务器被判断为客观下线时，监视这个下线主服务器的各个Sentinel会进行协商，选举出一个领头Sentinel，并由领头Sentinel对下线主服务器执行故障转移操作。

+ 多个Sentinel都有可能成为领头Sentinel。

+ 在一个配置纪元里，所有Sentinel都有一次将某个Sentinel设置为局部领头Sentinel的机会。并且局部领头一旦设置就不能再更改。

+ 每个发现主服务器进入客观下线的Sentinel都会要求其他Sentinel将自己设置为局部领头Sentinel。

+ Sentinel设置局部领头Sentinel的规则是先到先得，最先向目标Sentinel发送的源Sentinel将成为目标Sentinel的局部领头Sentinel。

+ 目标Sentinel在接受到源Sentinel的要求之后，返回目标Sentinel的局部领头Sentinel的运行ID。

+ 如果由某个Sentinel被半数以上的Sentinel设置成了局部领头Sentinel，那么这个Sentinel成为领头Sentinel。

+ 如果在给定时限内，没有一个Sentinel被选举为领头Sentinel，那么各个Sentinel将在一段时间之后再次进行选举，直到选出领头Sentinel为止。

### 如何从Sentinal集群中选择出Leader？



### Sentinel可以防止脑裂吗？



### 为什么需要Redis Cluster？解决了什么问题？有什么优势？

Redis集群是Redis提供的分布式数据库方案，集群通过分片来进行数据共享，并提供复制和故障转移功能。

### Redis Cluster是如何分片的？

Redis集群通过分片的方式来保存数据库中的键值对：

集群的整个数据库被分为16384个槽，数据库中每个键都属于这16384个槽其中一个，集群的每个节点可以处理0个或最多16384个槽。

**slots**是一个二进制数组，共包含16384个二进制位。

Redis以0为起始索引，16383为终止索引，对slots数组中的16384个二进制位进行编号，并根据索引i上二进制位的值来判断节点是否负责处理槽i。

一个节点除了会将自己负责处理的槽记录在结构中之外，还会将自己的slots数组通过消息发送给集群中的其他节点，以此来告知其他节点自己目前负责处理哪些槽。因此，集群中的每个节点都会知道数据库中的16384个槽分别被指派给了集群中哪些节点。

### 为什么Redis Cluster的哈希槽是16384个？



### 如何确定给定的key应该分布到哪个哈希槽中？

+ 在大多数实现中，哈希槽的计算公式为`index=hash(key)%16384`。

### Redis Cluster支持重新分配哈希槽吗？

Redis对集群单个槽slot进行重新分片的步骤如下：

1. 对目标节点发送命令，让目标节点准备好从源节点导入属于槽slot的键值对。

2. 对源节点发送命令，获得最多count个属于槽slot的键值对的键名。

3. 对于步骤2获得的每个键名，都向源节点发送一个命令，将被选中的键原子地从源节点迁移至目标节点。

4. 重复执行步骤3和步骤4，直到源节点保存的所有属于slot的键值对都被迁移到目标节点为止。

5. 向集群中任意一个节点发送指派信息，这个信息会通过消息发送至整个集群，最终集群中所有节点都会直到slot已被指派给目标节点。

### Redis Cluster扩容缩容期间可以提供服务吗？

Redis集群在扩容和缩容期间可以继续提供服务。在扩容缩容期间，客户端向源节点发送一个与数据库键有关的命令，并且命令要处理的数据库键恰好就属于正在被迁移的槽时：

+ 源节点先在自己的数据库里查找指定的键，如果找到就执行客户端发送的命令。

+ 相反，如果源节点没能在自己的数据库里找到指定的键，那么这个节点可能已经被迁移到了目标节点，源节点向客户端返回一个ASK错误，引导客户端转向正在导入槽的目标节点。

### Redis Cluster中的节点怎么进行通信？

Redis集群中的节点分为主节点和从节点，其中主节点用于处理槽，而从节点用于复制某个主节点，并在被复制的主节点下线时，代替下线主节点继续处理请求。
