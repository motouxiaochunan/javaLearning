# java并发笔记

## 并发级别

**阻塞**

一个线程是阻塞的，那么在其它线程释放资源之前，当前线程无法继续执行。

**无饥饿**

如果线程之间是有优先级的，那么线程调度时倾向于满足高优先级的线程，系统允许高优先级的线程插队。

**无障碍**

无障碍是一种最弱的非阻塞调度，两个线程如果无障碍地执行，那么他们不会因为临界区的问题导致一方被挂起。当检测到线程同时修改共享数据时，线程会对自己所做的修改进行回滚。

当临界区中存在严重冲突时，所有线程可能不断回滚自己的操作，而没有一个线程能够走出临界区，所以希望至少有一个线程能够在有限时间内完成操作退出临界区。一个可行的实现是依赖一个一致性标记。线程在操作之前先读取并保存这个标记，在操作完成后再次读取，检查这个标记是否被更改过。

**无锁**

无锁的并行无障碍，在无锁的情况下所有线程都能尝试对临界区进行访问。无锁可能会包含一个无穷循环，在这个循环中线程会不断尝试修改共享变量，如果没有冲突则修改成功，否则继续尝试修改。

**无等待**

无等待在无锁的基础上更进一步扩展，所有的线程都必须在有限步内完成。一种典型的无等待结构是RCU，对所有的数据读不加控制。

## JMM

**原子性**

原子性指一个操作是不可中断的，即使多线程执行，一个操作开始就不会被其它线程干扰。

long数据的读写不是原子性的，两个线程对long进行写入，对线程之间的结果是有干扰的。

**可见性**

可见性是指当一个线程修改了某一个共享变量的值，其它线程是否能够立即知道这个修改。

比如在CPU1上的线程将变量t进行优化，将其缓存在cache或寄存器里，如果CPU2上的某个线程修改了变量t的实际值，那么CPU1上的线程可能无法意识到这个改动，依然读取cache或寄存器中的数据。

**有序性**

在并发时，程序的执行可能会出现乱序，因为可能会出现指令重排，重排后的指令与原指令的顺序未必一致。

对于一个线程来说，它看到的指令执行顺序一定是一致的，即串行语义具有一致性。

之所以需要做指令重排，就是为了尽量减少流水线的中断次数。如果按顺序执行，某些指令可能还在等待数据准备完成，因此将不需要等待的指令提前。

**哪些指令不能重排**

1.一个线程内保证语义的串行性。

2.volatile规则，volatile变量的写先发生于读，从而保证volatile变量的可见性。

3.传递性：A先于B，B先于C，那么A先于C。

4.线程的start()方法先于它的每一个动作。

5.线程所有操作先于它的终结。

6.线程的中断先于被中断的代码。

7.对象的析构函数执行结束先于finalize方法。

## 线程基本操作

**新建线程**

new关键字创建一个线程对象，将它start即可。

**终止线程**

使用stop()很难确定线程终止于哪一步

一般在run方法的循环执行中设置一个标记位，将标记位作为程序的退出点。

**wait和notify**

wait和notify都不是Thread类，而是Object类

在一个对象实例上调用obj.wait()后，当前线程就会在这个对象上等待，等到其它线程调用了obj.notify()位置

当object.notify()被调用时，它会从等待队列中完全随机地选择一个线程并将其唤醒。

wait会释放目标对象的锁，sleep方法不会释放任何资源

**volatile**

意为易变的，不稳定的

用volatile申明变量等于告诉虚拟机这个变量极有可能被某些程序或者线程修改，虚拟机必须采用一些特殊手段保证这个变量的可见性。

但volatile无法保证一些复合操作的原子性，比如i++。

**线程优先级**

Thread类setPriority方法

数字越大优先级越高

**synchronized**

synchronized关键字的作用是实现线程间的同步。

synchronized可以有多种用法：

+ 指定加锁对象，进入同步代码前要获得给定对象的锁。

+ 直接作用于实例方法，对当前实例加锁，进入同步代码前要获得当前实例的锁。

+ 直接作用于静态方法，对当前类加锁，进入同步代码前要获得当前类的锁。

synchronized可以完全替代volatile功能。

## 并发中的隐蔽错误(补集合知识)

### 并发下的ArrayList

1、程序正常结束

2、程序抛出异常ArrayIndexOutOfBoundsException

ArrayList在扩容过程中内部一致性被破坏，另外一个线程访问到了不一致的内部状态，导致出现越界行为。

3、出现一个非常隐蔽的错误。

多线程访问冲突，使得保存容器大小的变量被多线程不正常的访问，两个线程同时对ArrayList的同一个位置进行赋值。

改进方法：使用线程安全的Vector

### 并发下的HashMap

两个线程同时对HashMap进行put操作，如果一切正常，期望得到的map.size（）是100000。但实际上可能会得到以下三种情况：

1、程序正常结束，map的大小为100000。

2、程序正常结束，但map大小小于100000，不符合预期。

3、程序永远无法结束。

迭代遍历如同遍历一个链表，但当下由于多线程的冲突，链表结构已经遭到了破坏，链表成环了，当链表成环时，上述迭代等同于一个死循环。

使用ConcurrentHashMap替代HashMap

## JDK并发包

### 重入锁

在JDK5.0早期版本中，重入锁的性能远远好于synchronized

从6.0开始，两者性能差距并不大

重入锁使用Java.util.concurrent.locks.ReentrantLock类实现

重入锁有着显示的操作过程，手动指定何时加锁，何时释放锁，因此对逻辑控制的灵活性远远好于synchronized。

重入指一个线程可以连续两次获得同一把锁，在第二次获得锁时不会产生死锁。

如果使用synchronized进行锁控制，产生的锁是非公平的，重入锁允许对公平性进行设置。公平锁要求系统维护一个有序队列，因此实现成本较高，因此默认情况下锁是非公平的。

**Condition条件**

Object.wait()和Object.notify()是和synchronized关键字合作使用的，Condition是与重入锁关联的。

### 读写锁

读写分离锁可以有效帮助减少锁竞争，比如多个读操作不对数据完整性造成破坏，不应该串行进行。

### 线程池

多线程可以最大限度发挥现代多核处理器的计算能力，但不加控制和管理，对系统性能反而产生不利影响。

当系统需要使用线程时，并不是创建一个新的连接，而是从线程池中获得一个可用的线程即可。反之，当需要关闭时，并不真的把线程关闭，

而是将这个线程还给线程池。

ThreadPoolExecutor表示一个线程池，通过这个接口，任何Runnable对象可以被ThreadPoolExecutor调度。

**线程池的创建**

+ newFixedThreadPool，返回一个固定线程数量的线程池。若没有空闲线程，新的任务会被暂存在一个任务队列中。

+ newSingleThreadPool，返回只有一个线程的线程池，如果没有空闲线程，新的任务会被暂存在一个任务队列中。

+ newCachedThreadPool，返回一个可根据实际情况调整线程数量的线程池，如果线程池中没有空闲线程，则创建新的线程处理任务。

+ newSingleThreadScheduledExecutor，扩展了在给定时间执行某任务的功能。

+ newScheduledThreadPool，同上但线程池可以指定线程数量。

ThreadPoolExecutor构造函数的参数：

+ corePoolSize线程池中的线程数量

+ maximumPoolSize线程池中最大线程数量

+ keepAliveTime：当线程池数量超过corePoolSize时，多余的空闲线程的存活时间。

+ unit：存活时间的单位

+ workQueue：被提交但未被执行的任务。

+ threadFactory：用于创建线程的工厂，一般默认。

+ handler：拒绝策略，当任务太多来不及处理时如何拒绝任务。

可以使用以下几种BlockingQueue：

+ 直接提交的队列SynchronousQueue（不太懂），没有容量，每一个插入操作都要等相应的删除操作

+ 有界任务队列，ArrayBlockingQueue，若有新的任务执行，线程池小于corePoolSize，则创建新的线程，若大于则将新任务加入等待队列。若等待队列已满，则在不大于maximumPoolSize的前提下创建新的进程执行任务，若大于maximumPoolSize，则拒绝。

+ 无界任务队列，与有界队列相比，除非系统资源耗尽否则不存在任务入队失败的情况。

+ 优先任务队列，是一个特殊的无界队列，有界队列和无界队列都是先进先出，而优先任务队列可以根据优先级顺序执行。

当线程池中线程用完了，等待队列也排满了，采用拒绝策略：

+ AbortPolicy，直接抛出异常，阻止系统正常工作。

+ CallerRunsPolicy：在调用者的线程中运行被丢弃的任务。

+ DiscardOledestPolicy：丢弃队列中即将被执行的一个任务，并尝试再次提交当前任务。

+ DiscardPolicy：默默丢弃无法处理的任务。

**线程池数量的估算**

Ncpu=CPU数量

Ucpu=目标CPU的使用率

W/C=等待时间与计算时间的比率

最佳的线程池大小等于：Nthreads=Ncpu*Ucpu\*(1+W/C)

### JDK并发容器

+ ConcurrentHashMap，线程安全的HashMap

+ CopyOnWriteArrayList在读多写少的场合性能远远好于Vector。

读取完全是不加锁的，写入也不会阻塞读取操作，只有写入和写入需要进行同步等待。

CopyOnWrite就是在写入操作时进行一次自我复制，将修改内容写进副本之中，再用修改完的副本替换原来的数据。

+ ConcurrentLinkedQueue线程安全的LinkedList。

+ BlockingQueue

当服务线程处理完队列中的所有消息，如何知道下一条消息何时到来？

BlockingQueue有offer、put、poll、take四个方法

put将元素压入队列末尾，如果队列满了它会等待直到有空闲的位置

take从队列头部获得元素，如果为空它会等待直到有可用元素

## 锁的优化以及注意事项

### 提高锁性能的建议

+ 减小锁持有时间

只有在必要时使用锁进行同步

+ 减小锁粒度

ConcurrentHashMap并不是对整个HashMap加锁，而是根据hashcode得到应该被存放到哪个段中，然后对该段加锁

但是当需要获取全局信息时，比如大小时ConcurrentHashMap需要获得所有子段的锁。

+ 读写分离锁来替换独占锁

+ 锁分离

比如BlockingQueue中的take和put使用两把不同的锁分离了操作，削弱了锁竞争的关系。

+ 锁粗化

当连续地对同一锁不断进行请求和释放操作时，把所有操作整合为对锁的一次请求。

### 虚拟机对锁优化的努力

**锁偏向**

如果一个线程获得了锁，那么锁就进入偏向模式，当这个线程再次请求锁时无需再做任何同步操作。

**轻量级锁**

将对象头部作为指针，指向持有锁的线程堆栈内部，来判断一个线程是否持有对象锁。

**自旋锁**

虚拟机让当前线程做几个空循环，如果能得到锁，就顺利进入临界区，如果还不能获得锁，才会将线程挂起。

**锁消除**

虚拟机在JIT编译时，通过对上下文的扫描，去除不可能存在共享资源竞争的锁，来节省毫无意义的锁请求。

比如将Vector作为局部变量使用

### ThreadLocal

**如何保证对象只被当前线程访问**

在set时，首先获得当前线程对象，然后通过getMap()拿到线程的ThreadLocalMap，key为ThreadLocal当前对象，value为我们需要的值

变量是维护在Thread类内部的，只要线程不退出，对象引用一直存在

如果使用线程池，意味着当前线程未必会退出，将大对象设置到ThreadLocal中且不清理可能会出现内存泄漏

最好使用ThreadLocal.remove将其回收

将ThreadLocal的变量手动设置为null，加速回收

ThreadLocal的回收（不懂）

### 无锁

锁是一种悲观的策略，如果有多个线程同时访问临界区资源，就牺牲性能让线程等待。无锁是一种乐观的策略，使用一种叫做比较交换的技术(CAS)来鉴别线程冲突，一旦检测到冲突产生，就重试到没有冲突为止。

CAS包含三个参数CAS(V,E,N)

V表示要更新的变量，E表示预期值，N表示新值，当且仅当V=E时，才将V的值设为N，如果V值和E值不同则表明其它线程做了更新。

大部分现代处理器已经支持原子化的CAS指令

**AtomicInteger**

使用CAS操作来实现线程安全，与Integer不同，它是可变且线程安全的。

**AtomicReference**

和AtomicInteger非常类似，AtomicReference是对对象的封装。

CAS存在一种情况：获得对象当前数据后，在准备修改为新值前，对象的值被其它线程连续修改两次，而经过这两次修改后，对象的值又恢复为旧值。

如果进行数值修改，这并没有问题，但是在现实中可能还存在另一种场景，就是我们能否修改对象的值，不仅取决于当前值，还和对象的过程变化有关。

**AtomicStampedReference**

除了更新数据本身外，还必须更新时间戳来标注对象状态的改变

**SynchronousQueue**

任何一个对SynchronousQueue的写需要等待另一个队列的读

它将put和take两个功能截然不同的操作抽象为一个共通的方法Transfer.transfer()。

## 并行模式与算法

### 单例模式

单例模式的优势：

+ 对于频繁使用的对象可以省略new操作花费的时间。

+ 由于new操作次数减少，对系统内存使用频率降低，减轻GC压力。

### 不变模式

同步操作对系统有相当的损耗，为了尽可能去除这些同步操作，可以使用一种不可改变的对象。

不变模式的实现：

+ 去除setter方法以及所有修改自身属性的方法。

+ 将所有属性设置为私有，并用final标记。

+ 确保没有子类可以重载修改行为。

+ 有一个可以创建完整对象的构造函数。

### 生产者消费者模式

生产者线程负责提交用户请求，消费者线程则负责具体处理，生产者和消费者之间通过共享内存缓冲区进行通信

可以用Disruptor实现无锁的生产者消费者模式

### Future模式

它的核心思想是异步调用，当我们需要调用一个函数方法时，如果这个函数执行很慢，可以让被调者立即返回在后台慢慢处理请求。

**JDK中的Future模式**

### 网络NIO

NIO指java newIO

对于标准网络IO，使用Socket进行网络读写，为了让服务器可以支持更多的客户端连接，通常的做法是为每一个客户端连接开启一个线程。

为了接受客户端连接，服务器还会额外使用一个派发线程。

服务端需要等待客户端的输入，而客户端缓慢的处理速度使得服务器花费了不少等待时间。

**使用NIO进行网络编程**

Channel类似于流，可以对应一个Socket，往Channel中写数据等同于向Socket中写入数据。

Buffer可以理解为一个内存区域，数据需要包装成Buffer的形式才可以和Channel交互。

Selector可以管理多个Channel，当数据准备好时，Selector就会接到通知，得到已经准备号的数据。

### AIO

NIO是在IO操作准备好时，由这个线程自行进行IO操作，而AIO是在IO操作已经完成后，再给线程发出通知。
